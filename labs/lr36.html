<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Лабораторная работа: Скорость поверхностной волны</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f4f7f6; color: #333; padding: 20px; line-height: 1.6; position: relative; }
        .container { max-width: 1000px; margin: 0 auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); position: relative; }
        
        /* Тумблер переключения языков */
        .lang-switch { position: absolute; top: 20px; right: 20px; display: flex; align-items: center; gap: 8px; font-weight: bold; font-size: 14px; }
        .switch { position: relative; display: inline-block; width: 40px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 20px; }
        .slider:before { position: absolute; content: ""; height: 14px; width: 14px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #3498db; }
        input:checked + .slider:before { transform: translateX(20px); }

        h1 { font-size: 22px; color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; margin-bottom: 10px; padding-right: 120px; }
        
        .theory-block { background: #f8f9fa; padding: 15px; border-left: 4px solid #3498db; margin-bottom: 20px; border-radius: 0 4px 4px 0; }
        .theory-block p { margin: 5px 0; font-size: 14px; }
        .formula { font-weight: bold; background: #eef2f3; padding: 2px 6px; border-radius: 4px; font-family: monospace; font-size: 16px;}

        canvas { background-color: #e0f7fa; border: 2px solid #b2ebf2; border-radius: 4px; display: block; margin: 20px 0; width: 100%; height: 200px; transition: 0.2s; }
        
        .controls { display: flex; gap: 15px; align-items: center; margin-bottom: 10px; background: #ecf0f1; padding: 15px; border-radius: 6px; }
        button { background-color: #3498db; color: white; border: none; padding: 10px 20px; font-size: 16px; border-radius: 4px; cursor: pointer; transition: 0.3s; font-weight: bold;}
        button:hover { background-color: #2980b9; }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; }
        .reset-btn { background-color: #e67e22; }
        .reset-btn:hover { background-color: #d35400; }
        
        input[type="number"] { padding: 8px; font-size: 16px; border: 1px solid #ccc; border-radius: 4px; width: 80px; }
        
        .table-wrapper { overflow-x: auto; margin-top: 10px; }
        table { width: 100%; border-collapse: collapse; font-size: 14px; }
        th, td { border: 1px solid #bdc3c7; padding: 10px; text-align: center; }
        th { background-color: #34495e; color: white; }
        
        .status { font-weight: bold; color: #e74c3c; font-size: 16px;}
        
        .error-results { margin-top: 20px; padding: 15px; background: #eef2f3; border-radius: 6px; border-left: 4px solid #27ae60; display: none; }
        .error-results p { margin: 5px 0; font-size: 16px; }
    </style>
</head>
<body>

<div class="container">
    <div class="lang-switch">
        <span>RU</span>
        <label class="switch">
            <input type="checkbox" id="langToggle" onchange="toggleLanguage()">
            <span class="slider"></span>
        </label>
        <span>KZ</span>
    </div>

    <h1 id="t_title">Определение скорости распространения поверхностных волн</h1>
    
    <div class="theory-block">
        <p><b id="t_goal_label">Формулы:</b> 
            <span class="formula">V = l / t</span>, 
            <span class="formula">ΔV = (|V₁-V_ср| + |V₂-V_ср| + |V₃-V_ср|) / 3</span>, 
            <span class="formula">ε = (ΔV / V_ср) · 100%</span>
        </p>
    </div>

    <div class="controls">
        <label><span id="t_dist_label">Дальность l (0.5 - 1.0 м):</span> 
            <input type="number" id="distanceInput" min="0.5" max="1.0" step="0.1" value="0.8">
        </label>
        <button id="dropBtn" onclick="startExperiment()"><span id="t_btn_drop">Бросить шарик</span></button>
        <button id="resetBtn" class="reset-btn" onclick="resetExperiment()"><span id="t_btn_reset">Сброс данных</span></button>
        <span class="status" id="timerDisplay">Ожидание...</span>
    </div>

    <canvas id="vesselCanvas" width="900" height="200"></canvas>

    <div class="table-wrapper">
        <table id="resultTable">
            <thead>
                <tr>
                    <th id="th_exp">№ опыта</th>
                    <th id="th_t">Время, t, c</th>
                    <th id="th_l">Дальность, l, м</th>
                    <th id="th_v">Скорость, V, м/с</th>
                    <th id="th_t_avg">Среднее время, t_ср, c</th>
                    <th id="th_l_avg">Средняя дальность, l_ср, м</th>
                    <th id="th_v_avg">Средняя скорость, V_ср, м/с</th>
                </tr>
            </thead>
            <tbody id="tableBody"></tbody>
        </table>
    </div>
    
    <div class="error-results" id="errorResults">
        <p><b id="t_abs_err">Абсолютная погрешность ΔV =</b> <span id="val_abs" style="color: #c0392b; font-weight: bold;"></span> <span id="t_unit_v1">м/с</span></p>
        <p><b id="t_rel_err">Относительная погрешность ε =</b> <span id="val_rel" style="color: #2980b9; font-weight: bold;"></span> %</p>
    </div>
</div>

<script>
    const dict = {
        ru: {
            t_title: "Определение скорости распространения поверхностных волн",
            t_goal_label: "Формулы:",
            t_dist_label: "Дальность l (0.5 - 1.0 м):",
            t_btn_drop: "Бросить шарик",
            t_btn_reset: "Сброс данных",
            status_wait: "Ожидание...",
            status_wave: "Волна идет...",
            status_done: "Опыты завершены!",
            status_time: "Время:",
            th_exp: "№ опыта",
            th_t: "Время, t, c",
            th_l: "Дальность, l, м",
            th_v: "Скорость, V, м/с",
            th_t_avg: "Среднее время, t_ср, c",
            th_l_avg: "Средняя дальность, l_ср, м",
            th_v_avg: "Средняя скорость, V_ср, м/с",
            t_abs_err: "Абсолютная погрешность ΔV =",
            t_rel_err: "Относительная погрешность ε =",
            t_unit_v1: "м/с",
            alert_done: "Выполнено 3 опыта. Нажмите «Сброс данных» для новой серии.",
            alert_range: "Введите расстояние от 0.5 до 1.0 м"
        },
        kz: {
            t_title: "Беттік толқындардың таралу жылдамдығын анықтау",
            t_goal_label: "Формулалар:",
            t_dist_label: "Қашықтық l (0.5 - 1.0 м):",
            t_btn_drop: "Шарды тастау",
            t_btn_reset: "Деректерді тазарту",
            status_wait: "Күту...",
            status_wave: "Толқын жүріп жатыр...",
            status_done: "Тәжірибелер аяқталды!",
            status_time: "Уақыт:",
            th_exp: "Тәжірибе №",
            th_t: "Уақыт, t, c",
            th_l: "Қашықтық, l, м",
            th_v: "Жылдамдық, V, м/с",
            th_t_avg: "Орташа уақыт, t_орт, c",
            th_l_avg: "Орташа қашықтық, l_орт, м",
            th_v_avg: "Орташа жылдамдық, V_орт, м/с",
            t_abs_err: "Абсолютті қателік ΔV =",
            t_rel_err: "Салыстырмалы қателік ε =",
            t_unit_v1: "м/с",
            alert_done: "3 тәжірибе жасалды. Жаңа серия үшін «Деректерді тазарту» басыңыз.",
            alert_range: "0.5-тен 1.0 м-ге дейін енгізіңіз"
        }
    };

    let currentLang = 'ru';

    function toggleLanguage() {
        const isKz = document.getElementById('langToggle').checked;
        currentLang = isKz ? 'kz' : 'ru';
        for (let key in dict[currentLang]) {
            const el = document.getElementById(key);
            if (el && !key.startsWith('status_') && !key.startsWith('alert_')) {
                el.innerHTML = dict[currentLang][key];
            }
        }
        if (!isAnimating && attemptCount === 0) {
            document.getElementById('timerDisplay').innerText = dict[currentLang].status_wait;
        } else if (attemptCount === MAX_ATTEMPTS) {
            document.getElementById('timerDisplay').innerText = dict[currentLang].status_done;
        }
    }

    const canvas = document.getElementById('vesselCanvas');
    const ctx = canvas.getContext('2d');
    const dropBtn = document.getElementById('dropBtn');
    const distanceInput = document.getElementById('distanceInput');
    const timerDisplay = document.getElementById('timerDisplay');
    const tableBody = document.getElementById('tableBody');
    const errorBlock = document.getElementById('errorResults');
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    const REAL_WAVE_SPEED = 0.30; // м/с
    const PIXELS_PER_METER = 750; 

    let waves = []; 
    let isAnimating = false;
    let waveHitRecorded = false; 
    let startTime = 0;
    let distanceMeters = 0.8;
    let currentSpeedPxPerFrame = 0;
    let animationFrameId;
    
    const MAX_ATTEMPTS = 3; // По новой методичке ровно 3 опыта
    let attemptCount = 0;
    let data = { times: [], dists: [], vels: [] };

    distanceInput.addEventListener('input', (e) => {
        if (attemptCount === 0 && !isAnimating) {
            let val = parseFloat(e.target.value);
            if (val >= 0.5 && val <= 1.0) {
                distanceMeters = val;
                drawScene();
            }
        }
    });

    function playDropSound() {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(600, audioCtx.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 0.1);
        gainNode.gain.setValueAtTime(1, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 0.1);
    }

    function drawScene() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Линейка
        ctx.strokeStyle = '#34495e';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(50, canvas.height - 10);
        ctx.lineTo(50 + 1 * PIXELS_PER_METER, canvas.height - 10);
        ctx.stroke();
        
        // Засечки на линейке
        for(let i=0; i<=10; i+=1) {
            ctx.beginPath();
            let x = 50 + (i/10) * PIXELS_PER_METER;
            ctx.moveTo(x, canvas.height - 10);
            ctx.lineTo(x, canvas.height - (i%5===0 ? 20 : 15));
            ctx.stroke();
        }

        // Теннисный шарик (поплавок)
        const floatX = 50 + distanceMeters * PIXELS_PER_METER;
        ctx.fillStyle = '#f1c40f'; // Желтый теннисный мяч
        ctx.beginPath();
        ctx.arc(floatX, canvas.height / 2, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#e67e22';
        ctx.stroke();

        // Место броска (металлический шарик)
        ctx.fillStyle = '#7f8c8d';
        ctx.beginPath();
        ctx.arc(50, canvas.height / 2, 6, 0, Math.PI * 2);
        ctx.fill();
    }

    function startExperiment() {
        if (attemptCount >= MAX_ATTEMPTS) {
            alert(dict[currentLang].alert_done);
            return;
        }

        distanceMeters = parseFloat(distanceInput.value);
        if (distanceMeters < 0.5 || distanceMeters > 1.0) {
            alert(dict[currentLang].alert_range);
            return;
        }

        playDropSound();

        dropBtn.disabled = true;
        distanceInput.disabled = true; 
        
        waves = [0, -30, -60]; 
        waveHitRecorded = false;
        isAnimating = true;
        timerDisplay.innerText = dict[currentLang].status_wave;
        
        // Шум +-5%
        const noise = 1 + (Math.random() * 0.10 - 0.05); 
        const currentSpeedMs = REAL_WAVE_SPEED * noise;
        currentSpeedPxPerFrame = (currentSpeedMs * PIXELS_PER_METER) / 60; 

        startTime = performance.now();
        animationFrameId = requestAnimationFrame(animateWaves);
    }

    function animateWaves() {
        if (!isAnimating) return;

        drawScene();
        let allWavesPassed = true;
        const targetDistancePx = distanceMeters * PIXELS_PER_METER;

        for (let i = 0; i < waves.length; i++) {
            waves[i] += currentSpeedPxPerFrame;

            if (waves[i] > 0) {
                let alpha = Math.max(0, 1 - (waves[i] / (canvas.width * 0.8)));
                ctx.strokeStyle = `rgba(52, 152, 219, ${alpha})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(50, canvas.height / 2, waves[i], -Math.PI/2, Math.PI/2);
                ctx.stroke();
            }

            if (waves[i] < canvas.width) {
                allWavesPassed = false;
            }
        }

        if (waves[0] >= targetDistancePx && !waveHitRecorded) {
            waveHitRecorded = true;
            const endTime = performance.now();
            const timeSeconds = (endTime - startTime) / 1000;
            recordResult(timeSeconds);
        }

        if (!allWavesPassed) {
            animationFrameId = requestAnimationFrame(animateWaves);
        } else {
            isAnimating = false; 
            setTimeout(drawScene, 300); 
        }
    }

    function recordResult(t) {
        attemptCount++;
        let v = distanceMeters / t;
        
        data.times.push(t);
        data.dists.push(distanceMeters);
        data.vels.push(v);
        
        timerDisplay.innerText = `${dict[currentLang].status_time} ${t.toFixed(2)} с`;

        const tr = document.createElement('tr');
        
        if (attemptCount === MAX_ATTEMPTS) {
            let t_cp = data.times.reduce((a,b)=>a+b)/3;
            let l_cp = data.dists.reduce((a,b)=>a+b)/3;
            let v_cp = data.vels.reduce((a,b)=>a+b)/3;

            // Расчет погрешностей по формулам из PDF
            let sum_diff = Math.abs(data.vels[0]-v_cp) + Math.abs(data.vels[1]-v_cp) + Math.abs(data.vels[2]-v_cp);
            let delta_V = sum_diff / 3;
            let eps = (delta_V / v_cp) * 100;

            tr.innerHTML = `
                <td>${attemptCount}</td>
                <td>${t.toFixed(2)}</td>
                <td>${distanceMeters.toFixed(2)}</td>
                <td>${v.toFixed(3)}</td>
                <td><b>${t_cp.toFixed(2)}</b></td>
                <td><b>${l_cp.toFixed(2)}</b></td>
                <td><b style="color:#27ae60;">${v_cp.toFixed(3)}</b></td>
            `;
            timerDisplay.innerText = dict[currentLang].status_done;
            
            // Вывод погрешностей
            document.getElementById('val_abs').innerText = delta_V.toFixed(4);
            document.getElementById('val_rel').innerText = eps.toFixed(2);
            errorBlock.style.display = 'block';
            
        } else {
            tr.innerHTML = `
                <td>${attemptCount}</td>
                <td>${t.toFixed(2)}</td>
                <td>${distanceMeters.toFixed(2)}</td>
                <td>${v.toFixed(3)}</td>
                <td>-</td><td>-</td><td>-</td>
            `;
            dropBtn.disabled = false;
        }
        
        tableBody.appendChild(tr);
    }

    function resetExperiment() {
        isAnimating = false;
        cancelAnimationFrame(animationFrameId);
        
        attemptCount = 0;
        data = { times: [], dists: [], vels: [] };
        tableBody.innerHTML = ''; 
        errorBlock.style.display = 'none';
        
        dropBtn.disabled = false;
        distanceInput.disabled = false;
        timerDisplay.innerText = dict[currentLang].status_wait;
        
        distanceMeters = parseFloat(distanceInput.value);
        drawScene();
    }

    distanceMeters = parseFloat(distanceInput.value);
    toggleLanguage(); 
    drawScene();
</script>

</body>
</html>